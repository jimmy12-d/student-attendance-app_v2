import os
import tempfile
import traceback
from flask import Flask, request, jsonify
from flask_cors import CORS, cross_origin
from PIL import Image
import numpy as np
import base64
import io

from deepface import DeepFace
from google.cloud import storage
import firebase_admin
from firebase_admin import credentials, firestore, auth

# --- Configuration ---
# BUCKET_NAME is no longer needed for cache refresh, but might be useful elsewhere.
BUCKET_NAME = 'rodwell-attendance.firebasestorage.app'
# IMPORTANT: Replace with your actual Firebase Storage bucket name.
# You can find it in the Firebase console -> Storage.

# --- Firebase Initialization ---
try:
    # In Cloud Run, the service account is automatically available.
    # For local development, set the GOOGLE_APPLICATION_CREDENTIALS env var.
    cred = credentials.ApplicationDefault()
    firebase_admin.initialize_app(cred, {
        'storageBucket': BUCKET_NAME
    })
    db = firestore.client()
    print("Firebase Admin initialized successfully.")
except Exception as e:
    print(f"Error initializing Firebase Admin: {e}")
    db = None

storage_client = storage.Client()

app = Flask(__name__)
# Enable CORS with explicit configuration
CORS(app, 
     origins=['http://localhost:3000', 'https://localhost:3000'],
     methods=['GET', 'POST', 'OPTIONS'],
     allow_headers=['Content-Type', 'Authorization'],
     supports_credentials=True)

# Add explicit OPTIONS handler for preflight requests
@app.before_request
def handle_preflight():
    if request.method == "OPTIONS":
        response = jsonify()
        response.headers.add("Access-Control-Allow-Origin", "*")
        response.headers.add('Access-Control-Allow-Headers', "*")
        response.headers.add('Access-Control-Allow-Methods', "*")
        return response

# --- In-memory Cache for Enrolled Faces ---
# This will be a list of dicts: {'uid': student_uid, 'embedding': embedding_vector}
enrolled_embeddings_list = []
# Timestamp of the last cache refresh
last_cache_refresh = 0
CACHE_REFRESH_INTERVAL = 3600 # Refresh every hour (in seconds)


def refresh_enrolled_faces_cache():
    """
    Loads pre-computed facial embeddings directly from the 'facialEmbeddings'
    field in each student's Firestore document.
    """
    global enrolled_embeddings_list, last_cache_refresh
    print("Starting cache refresh from Firestore embeddings...")

    if not db:
        print("Firestore client not available. Skipping cache refresh.")
        return

    try:
        temp_embeddings_list = []
        # Query for all students that have the 'facialEmbeddings' field.
        students_ref = db.collection('students').where("facialEmbeddings", "!=", [])
        students = students_ref.stream()

        for student in students:
            student_uid = student.id
            student_data = student.to_dict()
            stored_embeddings = student_data.get("facialEmbeddings", [])
            
            if not stored_embeddings:
                continue

            # We use the first stored embedding for matching.
            # The embeddings must have been generated by the same model (e.g., FaceNet).
            # The stored embedding should be a simple list/vector of numbers.
            first_embedding = stored_embeddings[0]
            
            # This is a database of embeddings that DeepFace.find can search against.
            # The 'identity' key is what DeepFace.find returns, so we use 'uid' for that.
            temp_embeddings_list.append([
                f"{student_uid}/rep.pkl", # DeepFace expects a "file path" convention.
                first_embedding
            ])
            print(f"Cached embedding for student {student_uid}")

        # DeepFace.find requires a specific format for its database path.
        # It expects a list of lists, where each inner list is [identity_path, embedding_vector].
        enrolled_embeddings_list = temp_embeddings_list
        last_cache_refresh = time.time()
        print(f"Cache refresh completed. Total students cached: {len(enrolled_embeddings_list)}")

    except Exception as e:
        print(f"Error during cache refresh: {e}")
        traceback.print_exc()

# --- Utility Functions ---
def verify_firebase_token(request):
    """Verify Firebase ID token from the Authorization header."""
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return None
    id_token = auth_header.split('Bearer ')[1]
    try:
        decoded_token = auth.verify_id_token(id_token)
        return decoded_token
    except Exception as e:
        print(f"Token verification failed: {e}")
        return None

# --- API Routes ---
@app.route('/recognize', methods=['POST'])
@cross_origin()
def recognize_face():
    """
    Receives a base64 encoded image, recognizes the face,
    and returns student information.
    """
    # 1. Authorize the request
    decoded_token = verify_firebase_token(request)
    if not decoded_token:
        return jsonify({'error': 'Unauthorized request. Invalid or missing token.'}), 403

    # 2. Check and refresh cache if needed
    if time.time() - last_cache_refresh > CACHE_REFRESH_INTERVAL:
        refresh_enrolled_faces_cache()

    if not enrolled_embeddings_list:
        return jsonify({'error': 'No enrolled faces found in Firestore. Please enroll students first.'}), 500

    # 3. Process the incoming image
    data = request.get_json()
    if 'image' not in data:
        return jsonify({'error': 'Missing image data in request.'}), 400

    try:
        image_data = base64.b64decode(data['image'])
        img_array = np.array(Image.open(io.BytesIO(image_data)))

        # 4. Find the best match using DeepFace
        # This function calculates the embedding for the input image and compares it
        # against all embeddings in our pre-calculated list.
        # It returns a pandas DataFrame.
        dfs = DeepFace.find(
            img_path=img_array,
            db_path=enrolled_embeddings_list, # Use our cached list of embeddings directly
            model_name='FaceNet',
            distance_metric='cosine',
            enforce_detection=True, # Ensure a face is actually in the live image
            silent=True # Prevents DeepFace from printing progress bars to the console
        )
        
        # The result is a list of dataframes, one for each face found in the image.
        # We only care about the first face.
        if not dfs or dfs[0].empty:
            return jsonify({'status': 'unknown', 'message': 'No matching face found in the database.'}), 200

        # Get the top match
        best_match = dfs[0].iloc[0]
        # The identity is the "file path" we created, so we parse the UID from it.
        matched_uid = best_match['identity'].split('/')[0]

        # 5. Fetch student data from Firestore
        student_ref = db.collection('students').document(matched_uid)
        student_doc = student_ref.get()

        if not student_doc.exists:
             return jsonify({'status': 'unknown', 'message': f'Matching face found but no student record for UID {matched_uid}.'}), 200
        
        student_data = student_doc.to_dict()
        student_name = student_data.get('name', 'Unknown Student')

        # This is where you would add your attendance marking logic.
        # For now, we just return the recognized student's info.
        
        return jsonify({
            'status': 'recognized',
            'message': f'Welcome, {student_name}!',
            'studentName': student_name,
            'studentUid': matched_uid,
            'attendanceStatus': 'On-time' # Placeholder
        }), 200

    except ValueError as ve:
        # This error is often thrown by DeepFace if no face is detected in the input image.
        print(f"Face detection error: {ve}")
        return jsonify({'status': 'no_face_detected', 'message': 'Could not detect a face in the provided image.'}), 200
    except Exception as e:
        print(f"An error occurred during recognition: {e}")
        traceback.print_exc()
        return jsonify({'error': 'An internal server error occurred.'}), 500


@app.route('/generate-embedding', methods=['POST'])
@cross_origin()
def generate_embedding():
    """
    Receives an image (as base64 string), calculates its FaceNet embedding,
    and returns it. This is used by the enrollment Cloud Function.
    """
    # Security: In a production environment, you would want to secure this
    # endpoint, for example, by checking for a secret header or an
    # service-to-service authentication token.
    data = request.get_json()
    if 'image' not in data:
        return jsonify({'error': 'Missing image data in request.'}), 400

    try:
        image_data = base64.b64decode(data['image'])
        img_array = np.array(Image.open(io.BytesIO(image_data)))

        # Use enforce_detection=False because we trust the enrollment photos
        # are cropped and contain a face.
        embedding_obj = DeepFace.represent(
            img_path=img_array,
            model_name='FaceNet',
            enforce_detection=False
        )
        
        if not embedding_obj or 'embedding' not in embedding_obj[0]:
            return jsonify({'error': 'Could not generate embedding.'}), 500

        # Return just the vector
        return jsonify({'embedding': embedding_obj[0]['embedding']}), 200

    except Exception as e:
        print(f"An error occurred during embedding generation: {e}")
        traceback.print_exc()
        return jsonify({'error': 'An internal server error occurred during embedding generation.'}), 500


@app.route('/health', methods=['GET'])
@cross_origin()
def health_check():
    """A simple health check endpoint."""
    return "OK", 200

# --- Initial Cache Load ---
import time
# Load the cache on startup.
# In a real-world scenario, you might do this in a background thread
# or on the first request to avoid slow startup times.
refresh_enrolled_faces_cache()

if __name__ == '__main__':
    # This is used for local development.
    # Gunicorn will be used in production on Cloud Run.
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080))) 